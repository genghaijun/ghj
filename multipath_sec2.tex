\section{Background}
\label{background}
\subsection{Failure Repair and Multipath Routing}
Nowadays, network component failures have become routine events rather than exceptions.
Both the industry and the academia have paid attention to improving the network resilience,
and proposed various schemes from physical level methods such as optical routing protection,
to IP level approaches such as IP Fast Rerouting (IPFRR)\cite{IPFRR} that
has been standardized by the IETF. The basic idea of IPFRR is that,
when a node detects the failure of a link directly connected to itself,
it can immediate switch to backup paths that are specifically computed for this failure.
Based on this framework, the following two categories of rerouting mechanisms have been proposed.

The first category works in a local manner. Besides the primary next hop for forwarding
packets to a given destination, a node computes and stores
some alternative next hop, and chooses the alternate when the primary one will fail to work.
Since there is no global cooperation, the alternates have to be selected carefully,
so that no routing loop will be introduced.
The IETF standard \cite{LFA} defines specific rules for selecting such Loop Free Alternates (LFAs),
and we will introduce more details about them in the following subsections.
However, naively computing LFAs with these rules require multiple rounds of
shortest path tree (SPT) computation, and the cost increases proportionally with the
degree of a node, i.e., one SPT for each neighbor.
TBFH \cite{TBFH} and DMPA \cite{dmpa} achieve faster computation at the cost of tightening
the selection rules and less alternates being found.
FIR \cite{20071710572557} improves the protecting capability against a single link failure
by computing different alternates for packets from different incoming ports,
at the cost of an  increased computation overhead, and a restricted scenario,
i.e., only for protecting a link.

The second category computes a multi-hop repair path and requires explicit cooperation or
signaling between routers to ensure packets are indeed routed along this path.
Multi-topology routing\cite{apostolopoulos2006using, gjessing2006implementation} computes routes
on different backup network topologies tailored for specific failures, i.e.,
by removing the corresponding links or by increasing their associated weights.
Routers control which topology they activate by changing additional bits in the packet headers.
FCP \cite {20075110977789} carries link failure information in the IP Packet header
to allow routers to diagnose problems and select alternate paths.
%However, this scheme also requires considerable overhead to find the new working path
%when receiving a packet carrying root-cause failure messages.
Not-via \cite{not-via}\cite{20102012943182}\cite{Menth20101300} uses special not-via addresses
in establishing multi-hop protecting paths.
TOD \cite{Yang2018Fast} proposes tunneling on demand (TOD) to handle one or dual link failures,
but needs it additional signaling protocol to establish tunnels.

Besides failure repair, alternate next hops also find applications in multipath
routing \cite{andersen2002resilient, cho2012independent},
where multiple next hops can increase the bandwidth utilization, achieve load balancing, or
improve routing resilience and reliability, if loop free are guaranteed.
Equal-Cost Multipath Routing (ECMP) \cite{moy1998rfc} allows packets to be forwarded
along multiple paths of equal cost but relies on network operators to tune link costs.
Routing deflection \cite{Yang_Source:2006} extends rules of LFAs to allow more next hops
at the cost of greater implementation complexity.
Permutation Routing \cite{20122315088660, vo2013routing} creates permutations of routers
and offer forwarding alternatives for each permutation.
Path splicing\cite{Pathsplicing:2008} creates a set of slices for the network based on random
link-weight perturbations, and end systems control which slices the routers should use
by embedding control bits in packet headers.
Loops can also be avoided by computing Directed Acyclic Graphs (DAG) \cite{20094212373257,  20114214442265},
but the complexity also increases significantly.

Due to the simplicity of its mechanism, LFA has been implemented by commercial router
vendors like Cisco, Juniper and HuaWei, etc., and widely deployed. As it plays an important role
in real-world networks and also has a great potential in multipath routing, we study how to
implement it more efficiently, so that when faced with more complex networks,
it will not become a bottleneck.


\subsection{Network Model and Basic Notations}
A link state network is modeled as an undirected graph $G=(V^{G},E^{G})$,
where $V^{G}$ and $E^G$ respectively denote the set of nodes (routers) and the set of edges (links) in the network.
Every link $(u,v)\in E^{G}$ in the network  has a link weight $L^{G}(u,v)$ and
a link failure probability $r^{G}(u,v)$, both of which are non-negative.
We use $C_c^G(v)$ to denote the lowest cost from node $c$ to node $v$,
and use $N_{c}^G(v)$ to denote the set of next hops that $c$ can forward to when receiving a packet destined to the node $v$.
For a neighboring node $u$ of $v$, it is clear that $C_u^G(v)=C_v^G(u)=L^{G}(u,v)$.

In traditional link state routing protocols such as IS-IS or OSPF,
a node $c$ constructs such a graph $G$ from states carried by link state advertisements.
With a shortest path algorithm such as the Dijkstra's or the Bellman-Ford algorithm\cite{CLRS},
it builds a shortest path tree (SPT) $T_c^G$, where $c$ is the root of the tree, and all other nodes are included.
We use $D_c^G(x)$ to denote the descendants of node $x$ (including $x$ itself) in $T_c^{G}$,
then each direct child $x$ of $c$ is $c$'s next hop for packets destined to $x$'s descendents,
i.e., ``$N_{c}^{G}(v)=x$ iff $(c,x) \in E^{G}$ and $v \in D_{c}^{G}(x)$''.
For failure repair or multipath transmission,  more appropriate elements should be added to $N_{c}^{G}(v)$.

To support the algorithm design, we also define a dual graph $G_{(u,v)}$ for the prime graph $G$,
where the only difference between them is a simple sign reversion of link $(u,v)$'s cost,
i.e., $L^{G_{(u,v)}}(u,v)=-L^{G}(u,v)$.
These notations are summarized in Table \ref{notation},
and when the graph is clear from context, we simply omit the superscript $G$ from them.

\begin{table*}[t]
\setlength{\belowcaptionskip}{0pt}
\normalsize
\caption{Notations}
\label{notation}
\centering
\begin{tabular}{c|c|c}
\hline
full notation & when context is clear & definition \\
\hline
$G\!=\!(V^{G},E^{G})$ & $G=(V,E)$ & An undirected graph with nodes and edges\\
%\hline
%$V$&Set of nodes in the graph\\
%\hline
%$E$&Set of links in the graph\\
%\hline
%$R(v)$&Router-ID of node $v$\\
\hline
$L^{G}(u,v)$ & $L(u,v)$ & The direct link cost between node $u$ and node $v$ \\
\hline
$r^{G}(u,v)$ & $r(u,v)$ & The link failure probability between node $u$ and node $v$ \\
\hline
% $G'=G^w_{(u,v)}$ &  &  &The network topology when the edge $(l,m)\in E$ change its weight to $w$\\
%\hline
$T_c^{G}$ & $T_{c} $ & The shortest path tree rooted at node $c$\\
\hline
%$T_{c}^{G'}$ &Shortest path tree rooted at node $c$ in $G'$ \\
%\hline
$C_{c}^{G}(v)$ & $C_c(v)$ & The lowest cost from $c$ to $v$ in the graph \\
\hline
%$C_c^{G'}(d)$ &The shortest cost from node $c$  to node $d$ in the network $G'$\\
%\hline
%$N(v)$&Neighbors of node $v$\\
%\hline
$D_{c}^{G}(v)$ & $D_c(v)$ & The descendants of node $v$ (including $v$ itself) in $T_c$\\
\hline
%$D_c^{G'}(v)$&Descendants of node $v$ (itself is included) in $T_{c}^{G'}$\\
%\hline
$N_{c}^{G}(v)$ & $N_{c}(v)$ & The set of next hops computed by node $c$ for destination $v$\\
\hline
%$B_{c}(v)$&Best next-hop computed by node $c$ for destination node $v$\\

%\hline
%$p(v)$&tentative parent of $v$\\
%\hline
%$d(v)$&tentative cost from $c$ to $v$\\
%\hline
\end{tabular}
\end{table*}



\iffalse
We use $G'=G^w_{(u,v)}$ to represent a network topology when the edge
$(u,v)\in E$ change its weight to $w$ in the network $G=(V,E)$, $C_c^{G'}(d)$ is the lowest cost from node $c$  to node $d$ in the network $G'=G^w_{(u,v)}$. $T_{c}^{G'}$ denote the  shortest path tree rooted at node $c$ in the network $G'=G^w_{(u,v)}$.
We use $D_c^{G'}(v)$ to denote the descendants of node $v$ (itself is included) in $T_{c}^{G'}$.
For ease of reading, we summarize some  symbols in the Table \ref{notation}.
In the rest of the paper, we will omit the superscript $G$
in the notations when the network topology is $G$.
\fi

\subsection{Loop Free Alternates}

Loop-free Alternate (LFA)\cite{LFA} proposes several criteria for selecting  proper next hops,
including the Loop-free Criterion (LFC), the Node Protection Condition (NPC) and the Downstream Criterion (DC).
These criteria are designed to guarantee loop-freeness when alternative next hops are used for different failure scenarios,
and can be explained as follows.

\begin{figure}[t]
\centering
%\includegraphics[width=3in]{realcomputationoverhead}
\includegraphics[width=3in]{lfaexample}
\caption{An example for explaining LFA}
\label{lfaexample}
\end{figure}


LFC can protect against a single link failure, NPC can protect against a
single node failure, while DC is applicable to more complex failure scenarios.
We will now dive into the details of LFA.

\textbf{LFC:}
For packets destined to a destination $v$, node $c$ ($c \ne v$)
can forward them to its any neighboring node $x$ as long as $C_x(v)<C_c(v)+C_x(c)$,
and there will be no forwarding loop in the induced forwarding path.

\textbf{NPC:}
For packets destined to a destination $v$, node $c$ ($c \ne v$)
can forward them to its any neighboring node $x$ as long as $C_x(v)<C_x(f)+C_f(v)$, where $f$ is the default next hop from $c$ to $v$,
and there will be no forwarding loop in the induced forwarding path.

\textbf{DC:}
For packets destined to a destination $v$, node $c$ ($c \ne v$)
can forward them to its any neighboring node $x$ as long as $C_x(v)<C_c(v)$,
and there will be no forwarding loop in the induced forwarding path.


The LFC rule can be interpreted as the node $s$ is not on the shortest path from $x$ to $v$, NPC shows that the node $f$ is not on the shortest path from $x$ to $v$. DC rule indicates that the neighbor $x$ is closer to the destination $v$ then the node $s$ itself.
From the description of the three rules, we can see that the neighbor who accords with the NPC rule must conform to the LFC rule, but the reverse is not necessarily true. A neighbor who meets the LFC rule must conform to the DC rule, but vice versa. There is no specific relationship between DC and NPC.
The following is an example to explain the three rules in LFA.
Fig. \ref{lfaexample} shows a network topology consisting of 5 nodes and 6 links.
As shown in Fig. \ref{lfaexample}, the default next hop from node $c$ to node $d$ is $a$,
the default next hop from node $c$ to node $e$ is $b$, $C_c(d)=4$, $C_b(d)=5$.
The node $b$ can be used as a valid LFC next hop from the node $c$ to the destination node $d$ since $C_b(d)<C_b(c)+C_c(d)$.
However the node $b$ is not a valid NFC next hop from the node $c$ to the destination node $d$ since $C_b(d)=C_b(a)+C_a(d)$.
Since $C_a(e)=4<C_c(e)=5$, node $a$ can be a valid DC next hop from $c$ to $e$.
Node $a$ can also be a valid LFC next hop from $c$ to $e$ because $C_a(e)<C_c(e)+C_e(c)$.
Node $a$ can also be a valid NPC next hop from $c$ to $e$ because $C_a(e)<C_a(b)+C_b(e)$.
It can be seen that the node $a$ can be used as  LFC, DC, and NPC next hop from the node $c$ to the destination node $e$.

In order to achieve resilience routing,
the node $c$ can compute a candidate set of next-hops $N_{c}(v)$
for each destination $v$ ($v \!\neq\! c$) employing LFA, so that when a packet destined to $v$ arrives at $c$,
$c$ can select a next-hop from $N_{c}(v)$ and forward this packet to.


%Since the performance of routing and forwarding is critical to the Internet, routing protection algorithm has to be highly efficient to avoid becoming a bottleneck. However, the existing approaches often focus on finding more, or  disjoint paths, rather than reducing the computation or the communication overhead, which is the focus of this paper.

\iffalse In \cite{dmpa}, we propose a shortest path tree based multipath routing
algorithm called DMPA. DMPA guarantees loop-freeness of
the induced routing path by implicitly maintaining a partial
order of the routers underpinning it The time complexity of
DMPA does not depend on the degree of the calculating router.
However, the protection ration of DMPA is still lower than
the DC.
Unlike the above works, however, our main concerns are computational efficiency and network availability, as these are critical for the routing protection algorithm. Based on the existing work on this research area, we for the first time propose two routing protection algorithms (IAC and IAC) whose complexity is less than that of Dijkstra’s algorithm and also have a high network availability.

Unlike the above works, however, our main concerns
are computational efficiency and protection ratio, as these are
critical for the Algorithm. Based on the existing work on this
research area, we for the first time propose an algorithm whose
complexity is less than that of Dijkstras algorithm and without
degrading the protection ratio.
\fi

%Unlike the above works, however, our main concerns are computational efficiency and network availability, as these are critical for the routing protection algorithm. Based on the existing work on this research area, we for the first time propose a routing protection algorithm whose complexity is less than that of Dijkstra’s algorithm and also has a high network availability.



\iffalse
In this paper, we focus on protection schemes that (1) are computationally efficient,
(2) provide high network protection coverage.

and (3) preserve as much as possible the benefits
that multiple next-hop solutions have, such as no cooperation/signaling and load balancing.
\fi
\begin{table}
\caption{Comparison of Different Routing Protection Algorithms}
\label{britetable1}
\centering
%\large
\normalsize
\begin{tabular}{|c|c|c|c|c|c|c|}% 通过添加 | 来表示是否需要绘制竖线
\hline  % 在表格最上方绘制横线
Algorithm&LFC&NPC&DC\\
\hline
DMPA&$\times$&$-$&$\times$\\
\hline
TBFH&$\times$&$-$&$\times$\\
\hline  %在第一行和第二行之间绘制横线
IAC&$-$ &$-$&$\surd$\\
\hline % 在表格最下方绘制横线
IAC&$\surd$ &$\surd$&$\surd$\\
\hline % 在表格最下方绘制横线
\end{tabular}

\end{table}


A comparison of several existing solutions and ours can be
seen in Table \ref{britetable1}.
In Table \ref{britetable1}, the $\surd$ describes the algorithm that can
compute all the next hop set satisfied the corresponding rule,
the $\times$ means the algorithm can
compute the partial  next hop set satisfied the corresponding rule,
while the $-$ represents the algorithm cannot compute the next hop set of corresponding rule.
As shown in table \ref{britetable1}, only IAC can be applied to three LFA rules and can compute all the next hops  that meet the LFA rule. The other three algorithms do not support NPC rule.
Both of the DMPA and TBFH  can be  used to deal with LFC and DC rule. However  DMPA and TBFH cannot compute all the next hops which satisfied LFC and DC rules.


Evaluation studies \cite{Gjoka2007Evaluation,Menth20101300} show that LFA protects against
many more failures than ECMP. Nevertheless, they also reveal that, on
average, LFA offers protection against only about 90\%
of all possible link failures and less than 75\% of node failures
Despite the limited protection it achieves, LFA is already supported by some equipment vendors \cite{cisco,Juniper}. With that in mind,
Retvari et al. \cite{lfarevisited} suggested that networks should be augmented with additional links to ensure that LFA can provide recovery
for all possible failures.
Therefore, our algorithms can directly use the above research findings, so that they can protect all single network component failure scenarios in the network.

